<!doctype html>

<html lang="id">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Catur PvC – Engine Sulit (HTML)</title>
<style>
  :root{ --bg:#0f172a; --card:#111827; --muted:#94a3b8; --accent:#6366f1; --good:#10b981; --warn:#f59e0b; }
  html,body{height:100%;}
  body{margin:0;background:var(--bg);color:#e5e7eb;font-family:system-ui,-apple-system,Segoe UI,Roboto,Ubuntu,Cantarell,Noto Sans,sans-serif;}
  .container{max-width:1100px;margin:0 auto;padding:16px;display:grid;grid-template-columns:1fr;gap:16px}
  @media(min-width:960px){.container{grid-template-columns:1fr 1fr}}
  .card{background:var(--card);border-radius:16px;box-shadow:0 20px 40px #0005;padding:16px}
  h1{font-size:20px;margin:0 0 8px}
  .board{display:grid;grid-template-columns:repeat(8,1fr);border-radius:16px;overflow:hidden}
  .sq{position:relative;aspect-ratio:1/1;display:flex;align-items:center;justify-content:center;cursor:pointer;font-size:40px}
  .light{background:#a7f3d0}
  .dark{background:#047857}
  .sel{outline:4px solid #facc15}
  .dot{position:absolute;width:16px;height:16px;border-radius:50%;background:#0006}
  .controls button,.controls input,.controls select{border:none;border-radius:14px;padding:8px 12px;background:#1f2937;color:#e5e7eb}
  .controls button:hover{background:#374151}
  .btn-primary{background:var(--accent)}.btn-primary:hover{filter:brightness(1.1)}
  .grid{display:grid;gap:10px}
  .two{grid-template-columns:1fr 1fr}
  .list{max-height:220px;overflow:auto}
  code{word-break:break-all}
  .small{opacity:.8;font-size:12px}
</style>
</head>
<body>
  <div class="container">
    <div>
      <div class="card" style="display:flex;align-items:center;justify-content:space-between">
        <h1>Catur PvC – Engine Sulit (HTML)</h1>
        <div class="small">Depth: <span id="depthDisp">6</span> | Time: <span id="timeDisp">2000</span>ms</div>
      </div>
      <div class="board card" id="board"></div>
      <div class="card controls" style="display:flex;flex-wrap:wrap;gap:8px;margin-top:8px">
        <button class="btn-primary" id="newGame">New Game</button>
        <button id="reset">Reset</button>
        <button id="undo">Undo x2</button>
        <button id="flip">Flip</button>
        <button id="switchSide">Main Hitam</button>
        <button id="hint" class="" >Hint</button>
        <button id="copyFen">Copy FEN</button>
        <button id="copyPgn">Copy PGN</button>
        <button id="importFen">Import FEN</button>
      </div>
      <div class="card grid two" style="margin-top:8px">
        <label>Level (Depth)
          <input type="range" min="2" max="10" value="6" id="depth" />
        </label>
        <label>Waktu/gerak (ms)
          <input type="range" min="300" max="5000" step="100" value="2000" id="timeMs" />
        </label>
      </div>
    </div>
    <div class="grid" style="gap:16px">
      <div class="card">
        <div style="display:flex;justify-content:space-between;align-items:center">
          <b>Kontrol Engine</b>
          <span class="small" id="thinking">Siap</span>
        </div>
        <div id="hintBox" class="small" style="margin-top:8px;display:none">Hint: <code id="hintText"></code></div>
      </div>
      <div class="card">
        <b>Status</b>
        <div id="status" style="font-size:18px;margin-top:8px">Putih jalan</div>
      </div>
      <div class="card">
        <b>Riwayat (SAN)</b>
        <div class="list" id="moveList"><span class="small" style="opacity:.7">Belum ada langkah</span></div>
      </div>
      <div class="card small">
        <div>FEN Saat Ini:</div>
        <code id="fenBox"></code>
      </div>
    </div>
  </div><script>
// ==========================
// Konstanta & Utilitas
// ==========================
const WHITE=0, BLACK=1;
const PIECES={EMPTY:0,wP:1,wN:2,wB:3,wR:4,wQ:5,wK:6,bP:7,bN:8,bB:9,bR:10,bQ:11,bK:12};
const PIECE_TO_CHAR={1:"♙",2:"♘",3:"♗",4:"♖",5:"♕",6:"♔",7:"♟",8:"♞",9:"♝",10:"♜",11:"♛",12:"♚"};
const MVV={1:100,2:300,3:320,4:500,5:900,6:20000,7:100,8:300,9:320,10:500,11:900,12:20000};
const START_FEN="rnbqkbnr/pppppppp/8/8/8/8/PPPPPPPP/RNBQKBNR w KQkq - 0 1";
const SQ=(f,r)=> (r<<4)|f, FILE=sq=>sq&15, RANK=sq=>sq>>4, OFFBOARD=sq=>(sq&0x88)!==0;
const isWhite=p=>p&&p<7, isBlack=p=>p&&p>=7, color=p=>(p>=7?BLACK:WHITE), opp=c=>c^1;
const KNIGHT=[31,33,14,-14,-31,-33,18,-18], KING=[1,-1,16,-16,15,-15,17,-17];
const BISHOP=[15,17,-15,-17], ROOK=[1,-1,16,-16], QUEEN=[...BISHOP,...ROOK];

const PST={P:[0,0,0,0,0,0,0,0,5,10,10,-20,-20,10,10,5,5,-5,-10,0,0,-10,-5,5,0,0,0,20,20,0,0,0,5,5,10,25,25,10,5,5,10,10,20,30,30,20,10,10,50,50,50,50,50,50,50,50,0,0,0,0,0,0,0,0],
N:[-50,-40,-30,-30,-30,-30,-40,-50,-40,-20,0,0,0,0,-20,-40,-30,0,10,15,15,10,0,-30,-30,5,15,20,20,15,5,-30,-30,0,15,20,20,15,0,-30,-30,5,10,15,15,10,5,-30,-40,-20,0,5,5,0,-20,-40,-50,-40,-30,-30,-30,-30,-40,-50],
B:[-20,-10,-10,-10,-10,-10,-10,-20,-10,0,0,0,0,0,0,-10,-10,0,5,10,10,5,0,-10,-10,5,5,10,10,5,5,-10,-10,0,10,10,10,10,0,-10,-10,10,10,10,10,10,10,-10,-10,5,0,0,0,0,5,-10,-20,-10,-10,-10,-10,-10,-10,-20],
R:[0,0,0,0,0,0,0,0,5,10,10,10,10,10,10,5,-5,0,0,0,0,0,0,-5,-5,0,0,0,0,0,0,-5,-5,0,0,0,0,0,0,-5,-5,0,0,0,0,0,0,-5,0,0,0,5,5,0,0,0],
Q:[-20,-10,-10,-5,-5,-10,-10,-20,-10,0,0,0,0,0,0,-10,-10,0,5,5,5,5,0,-10,-5,0,5,5,5,5,0,-5,0,0,5,5,5,5,0,-5,-10,5,5,5,5,5,0,-10,-10,0,5,0,0,0,0,-10,-20,-10,-10,-5,-5,-10,-10,-20],
K:[-30,-40,-40,-50,-50,-40,-40,-30,-30,-40,-40,-50,-50,-40,-40,-30,-30,-40,-40,-50,-50,-40,-40,-30,-30,-40,-40,-50,-50,-40,-40,-30,-20,-30,-30,-40,-40,-30,-30,-20,-10,-20,-20,-20,-20,-20,-20,-10,20,20,0,0,0,0,20,20,20,30,10,0,0,10,30,20]};
const pstIndex=(p,sq)=>{const f=FILE(sq), r=RANK(sq), idx=(7-r)*8+f, t=p%6||6, k=[, 'P','N','B','R','Q','K'][t]; let v=PST[k][idx]; if(isBlack(p)) v=PST[k][63-idx]; return v};

function rand32(){ return (Math.floor(Math.random()*0xffffffff)>>>0) }
const ZOB=(()=>{const a=new Uint32Array(13*128+64);for(let i=0;i<a.length;i++)a[i]=rand32();return a})();

// ==========================
// State & FEN
// ==========================
function emptyState(){return{board:new Array(128).fill(0),side:WHITE,castle:15,ep:-1,half:0,full:1,history:[],pgn:[],hash:0}};
function pieceToFen(p){return{1:'P',2:'N',3:'B',4:'R',5:'Q',6:'K',7:'p',8:'n',9:'b',10:'r',11:'q',12:'k'}[p]||''}
function sqToAlg(sq){return 'abcdefgh'[FILE(sq)]+(RANK(sq)+1)}
function algToSq(s){return SQ('abcdefgh'.indexOf(s[0]),parseInt(s[1])-1)}
function computeHash(s){let h=0;for(let sq=0;sq<128;sq++){if(OFFBOARD(sq))continue;const p=s.board[sq];if(p) h^=ZOB[(p*128+sq)%ZOB.length]}h^=ZOB[(13*128 + s.castle)%ZOB.length];if(s.ep!==-1)h^=ZOB[(13*128+32+FILE(s.ep))%ZOB.length];h^=ZOB[(13*128+48+s.side)%ZOB.length];return h>>>0}
function parseFEN(fen){const s=emptyState();const [piecePart,active,cast,ep,half,full]=fen.trim().split(/\s+/);let sq=SQ(0,7);for(const ch of piecePart){if(ch==='/' ){sq=SQ(0,RANK(sq)-1);continue}if(/[1-8]/.test(ch)){sq+=parseInt(ch);continue}const map={p:7,n:8,b:9,r:10,q:11,k:12,P:1,N:2,B:3,R:4,Q:5,K:6};s.board[sq]=map[ch];sq++}s.side=active==='w'?WHITE:BLACK;let c=0;if(cast.includes('K'))c|=8;if(cast.includes('Q'))c|=4;if(cast.includes('k'))c|=2;if(cast.includes('q'))c|=1;s.castle=c;s.ep=ep==='-'?-1:algToSq(ep);s.half=parseInt(half||'0');s.full=parseInt(full||'1');s.hash=computeHash(s);return s}
function boardToFEN(s){let fen='';for(let r=7;r>=0;r--){let empty=0;for(let f=0;f<8;f++){const sq=SQ(f,r),p=s.board[sq];if(!p)empty++;else{if(empty){fen+=empty;empty=0}fen+=pieceToFen(p)}}if(empty)fen+=empty;if(r)fen+='/'}fen+=' '+(s.side===WHITE?'w':'b')+' ';let c='';if(s.castle&8)c+='K';if(s.castle&4)c+='Q';if(s.castle&2)c+='k';if(s.castle&1)c+='q';fen+=c||'-';fen+=' '+(s.ep===-1?'-':sqToAlg(s.ep));fen+=' '+s.half+' '+s.full;return fen}

// ==========================
// Gerak & Legalitas
// ==========================
function genPawn(s,sq,dir,m){const side=dir===1?WHITE:BLACK;const start=dir===1?1:6;const promo=dir===1?7:0;const one=sq+16*dir,two=sq+32*dir;if(!OFFBOARD(one)&&!s.board[one]){if(RANK(one)===promo)addPromos(m,sq,one,s.board[sq]);else m.push({from:sq,to:one,piece:s.board[sq]});if(RANK(sq)===start&&!s.board[two])m.push({from:sq,to:two,piece:s.board[sq],epSet:sq+16*dir})}for(const df of[-1,1]){const to=one+df;if(OFFBOARD(to))continue;const tp=s.board[to];if(tp&&color(tp)!==side){if(RANK(to)===promo)addPromos(m,sq,to,s.board[sq],tp);else m.push({from:sq,to,piece:s.board[sq],capture:tp})}}if(s.ep!==-1){for(const df of[-1,1]){const to=one+df;if(to===s.ep)m.push({from:sq,to,piece:s.board[sq],capture:side===WHITE?PIECES.bP:PIECES.wP,ep:true})}}}
function addPromos(m,from,to,piece,capture){const promos=piece===PIECES.wP?[PIECES.wQ,PIECES.wR,PIECES.wB,PIECES.wN]:[PIECES.bQ,PIECES.bR,PIECES.bB,PIECES.bN];for(const pr of promos)m.push({from,to,piece,capture,promo:pr})}
function genLeaper(s,sq,dirs,m){const side=color(s.board[sq]);for(const d of dirs){const to=sq+d;if(OFFBOARD(to))continue;const tp=s.board[to];if(!tp)m.push({from:sq,to,piece:s.board[sq]});else if(color(tp)!==side)m.push({from:sq,to,piece:s.board[sq],capture:tp})}}
function genSlider(s,sq,dirs,m){const side=color(s.board[sq]);for(const d of dirs){let to=sq+d;while(!OFFBOARD(to)){const tp=s.board[to];if(!tp)m.push({from:sq,to,piece:s.board[sq]});else{if(color(tp)!==side)m.push({from:sq,to,piece:s.board[sq],capture:tp});break}to+=d}}}
function isSqAtt(s,sq,by){const dir=by===WHITE?1:-1;for(const df of[-1,1]){const from=sq-16*dir+df;if(!OFFBOARD(from)&&s.board[from]===(by===WHITE?PIECES.wP:PIECES.bP))return true}for(const d of KNIGHT){const from=sq+d;if(!OFFBOARD(from)&&s.board[from]===(by===WHITE?PIECES.wN:PIECES.bN))return true}for(const d of BISHOP){let t=sq+d;while(!OFFBOARD(t)){const p=s.board[t];if(p){if(color(p)===by&&((p%6)===3||(p%6)===5))return true;break}t+=d}}for(const d of ROOK){let t=sq+d;while(!OFFBOARD(t)){const p=s.board[t];if(p){if(color(p)===by&&((p%6)===4||(p%6)===5))return true;break}t+=d}}for(const d of KING){const from=sq+d;if(!OFFBOARD(from)&&s.board[from]===(by===WHITE?PIECES.wK:PIECES.bK))return true}return false}
function isKingAtt(s,side){for(let sq=0;sq<128;sq++){if(OFFBOARD(sq))continue;const p=s.board[sq];if((side===WHITE&&p===PIECES.wK)||(side===BLACK&&p===PIECES.bK))return isSqAtt(s,sq,opp(side))}return false}
function genKing(s,sq,m){genLeaper(s,sq,KING,m);const sd=color(s.board[sq]);if(sd===WHITE){if(s.castle&8){if(!s.board[SQ(5,0)]&&!s.board[SQ(6,0)]&&!isSqAtt(s,SQ(4,0),BLACK)&&!isSqAtt(s,SQ(5,0),BLACK)&&!isSqAtt(s,SQ(6,0),BLACK))m.push({from:SQ(4,0),to:SQ(6,0),piece:PIECES.wK,castle:'K'})}if(s.castle&4){if(!s.board[SQ(1,0)]&&!s.board[SQ(2,0)]&&!s.board[SQ(3,0)]&&!isSqAtt(s,SQ(4,0),BLACK)&&!isSqAtt(s,SQ(3,0),BLACK)&&!isSqAtt(s,SQ(2,0),BLACK))m.push({from:SQ(4,0),to:SQ(2,0),piece:PIECES.wK,castle:'Q'})}}else{if(s.castle&2){if(!s.board[SQ(5,7)]&&!s.board[SQ(6,7)]&&!isSqAtt(s,SQ(4,7),WHITE)&&!isSqAtt(s,SQ(5,7),WHITE)&&!isSqAtt(s,SQ(6,7),WHITE))m.push({from:SQ(4,7),to:SQ(6,7),piece:PIECES.bK,castle:'k'})}if(s.castle&1){if(!s.board[SQ(1,7)]&&!s.board[SQ(2,7)]&&!s.board[SQ(3,7)]&&!isSqAtt(s,SQ(4,7),WHITE)&&!isSqAtt(s,SQ(3,7),WHITE)&&!isSqAtt(s,SQ(2,7),WHITE))m.push({from:SQ(4,7),to:SQ(2,7),piece:PIECES.bK,castle:'q'})}}}
function generateMoves(s){const m=[];for(let sq=0;sq<128;sq++){if(OFFBOARD(sq))continue;const p=s.board[sq];if(!p||color(p)!==s.side)continue;switch(p){case 1:genPawn(s,sq,1,m);break;case 7:genPawn(s,sq,-1,m);break;case 2:case 8:genLeaper(s,sq,KNIGHT,m);break;case 3:case 9:genSlider(s,sq,BISHOP,m);break;case 4:case 10:genSlider(s,sq,ROOK,m);break;case 5:case 11:genSlider(s,sq,QUEEN,m);break;case 6:case 12:genKing(s,sq,m);break}}const legal=[];for(const mv of m){doMove(s,mv);if(!isKingAtt(s,opp(s.side)))legal.push(mv);undoMove(s);}return legal}

function doMove(s,m){const st={...m,prev:{castle:s.castle,ep:s.ep,half:s.half,full:s.full,hash:s.hash}};s.history.push(st);const{from,to,piece,capture,promo,ep,castle,epSet}=m;s.ep=-1;s.board[to]=promo?promo:piece;s.board[from]=0;if(ep){const capSq=to+(s.side===WHITE?-16:16);st.realCapSq=capSq;s.board[capSq]=0}if(castle){if(castle==='K'){s.board[SQ(5,0)]=PIECES.wR;s.board[SQ(7,0)]=0}else if(castle==='Q'){s.board[SQ(3,0)]=PIECES.wR;s.board[SQ(0,0)]=0}else if(castle==='k'){s.board[SQ(5,7)]=PIECES.bR;s.board[SQ(7,7)]=0}else if(castle==='q'){s.board[SQ(3,7)]=PIECES.bR;s.board[SQ(0,7)]=0}}const upd=(sqMove,pMoved)=>{if(pMoved===PIECES.wK)s.castle&=~12;if(pMoved===PIECES.bK)s.castle&=~3;if(sqMove===SQ(0,0)||to===SQ(0,0))s.castle&=~4;if(sqMove===SQ(7,0)||to===SQ(7,0))s.castle&=~8;if(sqMove===SQ(0,7)||to===SQ(0,7))s.castle&=~1;if(sqMove===SQ(7,7)||to===SQ(7,7))s.castle&=~2};upd(from,piece);if(epSet!==undefined)s.ep=epSet;if(capture||piece===1||piece===7)s.half=0;else s.half++;if(s.side===BLACK)s.full++;s.side^=1;s.hash=computeHash(s)}
function undoMove(s){const st=s.history.pop();const{from,to,piece,capture,promo,ep,castle,prev,realCapSq}=st;s.side^=1;s.board[from]=piece;s.board[to]=promo?0:(capture?capture:0);if(!promo&&capture)s.board[to]=capture;if(promo)s.board[to]=0;if(ep){s.board[realCapSq]=s.side===WHITE?PIECES.bP:PIECES.wP}if(castle){if(castle==='K'){s.board[SQ(7,0)]=PIECES.wR;s.board[SQ(5,0)]=0}else if(castle==='Q'){s.board[SQ(0,0)]=PIECES.wR;s.board[SQ(3,0)]=0}else if(castle==='k'){s.board[SQ(7,7)]=PIECES.bR;s.board[SQ(5,7)]=0}else if(castle==='q'){s.board[SQ(0,7)]=PIECES.bR;s.board[SQ(3,7)]=0}}s.castle=prev.castle;s.ep=prev.ep;s.half=prev.half;s.full=prev.full;s.hash=prev.hash}

// ==========================
// Evaluasi & Search
// ==========================
function evaluate(s){let score=0;for(let sq=0;sq<128;sq++){if(OFFBOARD(sq))continue;const p=s.board[sq];if(!p)continue;const val=[0,100,320,330,500,900,20000,100,320,330,500,900,20000][p];let pst=pstIndex(p,sq);score+=isWhite(p)?(val+pst):-(val+pst)}const save=s.side;s.side=WHITE;const w=generateMoves(s).length;s.side=BLACK;const b=generateMoves(s).length;s.side=save;score+=0.1*(w-b);return s.side===WHITE?score:-score}
const TT=new Map();const HASH_MASK=(1<<26)-1;const ttGet=k=>TT.get(k&HASH_MASK), ttPut=(k,e)=>TT.set(k&HASH_MASK,e);
const historyH=new Map();const killers=Array.from({length:64},()=>[null,null]);
const hk=m=>(m.piece<<7)|m.to; const same=(a,b)=>b&&a.from===b.from&&a.to===b.to&&a.promo===b.promo;
function order(moves,ttm,ply){for(const m of moves){if(ttm&&same(m,ttm)){m.score=1e9;continue}if(m.capture){m.score=5e5+MVV[m.capture]-(MVV[m.piece]||0);continue}const k=killers[ply]||[];if(k[0]&&same(m,k[0])){m.score=4e5;continue}if(k[1]&&same(m,k[1])){m.score=399999;continue}m.score=(historyH.get(hk(m))||0)}moves.sort((a,b)=>(b.score||0)-(a.score||0))}
let nodes=0;
function evalTerminal(s,ply){const legal=generateMoves(s);if(legal.length)return evaluate(s);if(isKingAtt(s,s.side===WHITE?WHITE:BLACK))return -100000+ply;return 0}
function quiescence(s,alpha,beta,start,limit){if(performance.now()-start>=limit)return evaluate(s);nodes++;let stand=evaluate(s);if(stand>=beta)return beta;if(stand>alpha)alpha=stand;const moves=generateMoves(s).filter(x=>x.capture||x.promo);order(moves,null,0);for(const m of moves){doMove(s,m);const sc=-quiescence(s,-beta,-alpha,start,limit);undoMove(s);if(sc>=beta)return beta;if(sc>alpha)alpha=sc}return alpha}
function alphaBeta(s,depth,alpha,beta,ply,start,limit){if(performance.now()-start>=limit)return evaluate(s);nodes++;const tt=ttGet(s.hash);if(tt&&tt.depth>=depth){if(tt.flag===0)return tt.score; if(tt.flag===-1&&tt.score<=alpha)return alpha; if(tt.flag===1&&tt.score>=beta)return beta}if(depth===0)return quiescence(s,alpha,beta,start,limit);const moves=generateMoves(s);if(moves.length===0){if(isKingAtt(s,s.side===WHITE?WHITE:BLACK))return -100000+ply;return 0}order(moves,tt?tt.best:null,ply);let best=null,oldA=alpha,bestSc=-1e9;for(const m of moves){doMove(s,m);const sc=-alphaBeta(s,depth-1,-beta,-alpha,ply+1,start,limit);undoMove(s);if(sc>bestSc){bestSc=sc;best={...m}}if(sc>alpha){alpha=sc;if(!m.capture){const key=hk(m);historyH.set(key,(historyH.get(key)||0)+depth*depth);if(!same(m,killers[ply][0])){killers[ply][1]=killers[ply][0];killers[ply][0]={...m}}}}if(alpha>=beta)break}let flag=0;if(bestSc<=oldA)flag=-1;else if(bestSc>=beta)flag=1;ttPut(s.hash,{depth,flag,score:bestSc,best});return bestSc}
function searchRoot(s,maxDepth,limit){nodes=0;const start=performance.now();let best=null,bScore=-1e9;const moves=generateMoves(s);if(moves.length===0)return{best:null,score:evalTerminal(s,0)};let d=1;while(d<=maxDepth&&(performance.now()-start)<limit){let localBest=null,localScore=-1e9;const tt=ttGet(s.hash);order(moves,tt?tt.best:null,0);for(const m of moves){doMove(s,m);const sc=-alphaBeta(s,d-1,-1e9,1e9,1,start,limit);undoMove(s);if(sc>localScore){localScore=sc;localBest={...m}}if(performance.now()-start>=limit)break}if(performance.now()-start>=limit)break;best=localBest;bScore=localScore;ttPut(s.hash,{depth:d,flag:0,score:bScore,best});d++}return{best,score:bScore,nodes}}

// ==========================
// SAN & PGN sederhana
// ==========================
function moveToSAN(s,m,legal){const piece=m.piece,isPawn=(piece%6)===1,to=m.to,capture=!!m.capture||m.ep; if(m.castle==='K'||m.castle==='k')return 'O-O'; if(m.castle==='Q'||m.castle==='q')return 'O-O-O'; let pc=isPawn?'':{2:'N',3:'B',4:'R',5:'Q',6:'K'}[piece%6]; let dis=''; if(!isPawn){const same=legal.filter(x=>x.to===to&&x.piece===piece&&x.from!==m.from); if(same.length){const sameFile=same.some(x=>FILE(x.from)===FILE(m.from)); const sameRank=same.some(x=>RANK(x.from)===RANK(m.from)); if(!sameFile)dis='abcdefgh'[FILE(m.from)]; else if(!sameRank)dis=String(RANK(m.from)+1); else dis=sqToAlg(m.from);}} let san=pc+dis+(capture?(isPawn? 'abcdefgh'[FILE(m.from)]+'x':'x'):'')+sqToAlg(to); if(m.promo){san+='='+{2:'N',3:'B',4:'R',5:'Q'}[m.promo%6]} doMove(s,m); const oppMoves=generateMoves(s); const inCheck=isKingAtt(s,s.side===WHITE?WHITE:BLACK); const mate=inCheck&&oppMoves.length===0; undoMove(s); if(mate) san+='#'; else if(inCheck) san+='+'; return san}

// ==========================
// UI & Interaksi
// ==========================
const boardEl=document.getElementById('board');
const statusEl=document.getElementById('status');
const fenBox=document.getElementById('fenBox');
const moveList=document.getElementById('moveList');
const thinkingEl=document.getElementById('thinking');
const hintBox=document.getElementById('hintBox');
const hintText=document.getElementById('hintText');
const depthInput=document.getElementById('depth');
const timeInput=document.getElementById('timeMs');
const depthDisp=document.getElementById('depthDisp');
const timeDisp=document.getElementById('timeDisp');

let S=parseFEN(START_FEN); S.pgn=[];
let selected=null; let legalMoves=generateMoves(S); let playingAs=WHITE; let flip=false; let maxDepth=6; let timeMs=2000; let thinking=false; let lastHint=null;

function refresh(){legalMoves=generateMoves(S);renderBoard();updateSideText();fenBox.textContent=boardToFEN(S);renderMoves();}
function updateSideText(){const legal=legalMoves;if(legal.length===0){if(isKingAtt(S,S.side===WHITE?WHITE:BLACK)) statusEl.textContent='Skak Mat! '+(S.side===playingAs?'Komputer menang.':'Anda menang!'); else statusEl.textContent='Stalemate';}
else statusEl.textContent=(S.side===WHITE?'Putih':'Hitam')+' jalan'}

function renderMoves(){if(!S.pgn.length){moveList.innerHTML='<span class="small" style="opacity:.7">Belum ada langkah</span>';return}const turns=[];for(let i=0;i<S.pgn.length;i+=2){const w=S.pgn[i]||'', b=S.pgn[i+1]||'';turns.push(`${1+(i>>1)}. ${w} ${b}`.trim())}moveList.innerHTML='<ol>'+turns.map(t=>`<li>${t}</li>`).join('')+'</ol>'}

function boardSquares(){const arr=[];for(let r=0;r<8;r++)for(let f=0;f<8;f++)arr.push(SQ(f,r));return flip?arr.reverse():arr}
function isLegalDest(sq){return legalMoves.some(m=>m.from===selected&&m.to===sq)}

function renderBoard(){boardEl.innerHTML='';boardEl.style.gridTemplateColumns='repeat(8,1fr)';for(const sq of boardSquares()){const p=S.board[sq];const f=FILE(sq),r=RANK(sq);const dark=(f+r)%2===1;const d=document.createElement('div');d.className='sq '+(dark?'dark':'light')+(selected===sq?' sel':'');d.onclick=()=>onSquareClick(sq);if(p){d.textContent=PIECE_TO_CHAR[p]}if(selected!==null&&isLegalDest(sq)){const dot=document.createElement('div');dot.className='dot';d.appendChild(dot)}boardEl.appendChild(d)}}

function onSquareClick(sq){if(thinking) return; if(S.side!==playingAs) return; if(selected===null){const p=S.board[sq]; if(!p||color(p)!==playingAs) return; selected=sq; renderBoard(); return} if(sq===selected){selected=null; renderBoard(); return} const mv=legalMoves.find(m=>m.from===selected&&m.to===sq); if(!mv){const p=S.board[sq]; if(p&&color(p)===playingAs){selected=sq; renderBoard(); return} selected=null; renderBoard(); return} const san=moveToSAN(S,mv,legalMoves); doMove(S,mv); S.pgn.push(san); selected=null; refresh(); engineTurn();}

async function engineTurn(){if(S.side===playingAs) return; thinking=true; thinkingEl.textContent='Komputer berpikir…'; await new Promise(requestAnimationFrame); const res=searchRoot(S,maxDepth,timeMs); if(res.best){const san=moveToSAN(S,res.best,legalMoves); doMove(S,res.best); S.pgn.push(san);} thinking=false; thinkingEl.textContent='Siap'; refresh();}

// Kontrol
function newGame(){S=parseFEN(START_FEN);S.pgn=[];selected=null;lastHint=null;hintBox.style.display='none';refresh();}
function reset(){S=parseFEN(START_FEN);S.pgn=[];selected=null;lastHint=null;hintBox.style.display='none';refresh();}
function undo(){if(S.history.length===0)return;undoMove(S);if(S.history.length>0)undoMove(S);if(S.pgn.length>0)S.pgn.pop();if(S.pgn.length>0)S.pgn.pop();refresh();}
function doFlip(){flip=!flip;renderBoard()}
function switchSide(){playingAs^=1;document.getElementById('switchSide').textContent=playingAs===WHITE?'Main Hitam':'Main Putih';refresh();engineTurn()}
function showHint(){const r=searchRoot(S,Math.min(maxDepth,6),Math.min(timeMs,1500));lastHint=r.best||null;if(lastHint){hintText.textContent=`${sqToAlg(lastHint.from)} → ${sqToAlg(lastHint.to)}${lastHint.promo?('='+pieceToFen(lastHint.promo).toUpperCase()):''}`;hintBox.style.display='block'}else{hintBox.style.display='none'}}
function copyFen(){navigator.clipboard.writeText(boardToFEN(S));alert('FEN disalin ke clipboard')}
function copyPgn(){const t=[];for(let i=0;i<S.pgn.length;i+=2){const w=S.pgn[i]||'',b=S.pgn[i+1]||'';t.push(`${1+(i>>1)}. ${w} ${b}`.trim())}const p=t.join(' ');navigator.clipboard.writeText(p);alert('PGN disalin ke clipboard')}
function importFen(){const f=prompt('Tempel FEN di sini:');if(!f)return;try{S=parseFEN(f.trim());S.pgn=[];selected=null;lastHint=null;hintBox.style.display='none';refresh()}catch(e){alert('FEN tidak valid')}}

// Hook UI
document.getElementById('newGame').onclick=newGame;
document.getElementById('reset').onclick=reset;
document.getElementById('undo').onclick=undo;
document.getElementById('flip').onclick=doFlip;
document.getElementById('switchSide').onclick=switchSide;
document.getElementById('hint').onclick=showHint;
document.getElementById('copyFen').onclick=copyFen;
document.getElementById('copyPgn').onclick=copyPgn;
document.getElementById('importFen').onclick=importFen;
depthInput.oninput=e=>{maxDepth=parseInt(e.target.value);depthDisp.textContent=maxDepth}
timeInput.oninput=e=>{timeMs=parseInt(e.target.value);timeDisp.textContent=timeMs}

// Init
refresh();
</script></body>
</html>
